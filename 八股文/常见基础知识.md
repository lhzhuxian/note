### OSI七层模型

应用层：为应用程序提供服务
表示层：数据格式转化，数据加密
会话层：建立，管理和维护会话
传输层：建立，管理和维护端到端的连接(TCP)
网络层：IP选址及路由选择(IP)
数据链路层：物理寻址，同时将原始比特流转换为逻辑传输线路(ARP)
物理层：通过物理介质传输比特流

### TCP VS UDP

TCP(Transmission Control Protocol)和UDP(User Datagram Protocol)的区别
UDP: 无连接的协议，不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。有单播，多播，广播的功能。不可靠性。面向报文的。头部开销小，传输数据报文时是很高效的。
TCP: 面向连接的、可靠的、基于字节流的传输层通信协议。仅支持单播传输
TCP头定义，共20个字节
UDP头定义，共8个字节
TCP连接过程 -》 三次握手协议
第一次握手：客户端 -》 服务端 请求连接，发送SYN(Synchronize Sequence Numbers)，进入SYN-SEND 状态
第二次握手：服务端 -》 客户端 同意连接，发送SYN+ACK，进入SYN-RECEIVED 状态
第三次握手：客户端 -》 服务端 确认连接，发送ACK，进入ESTABLISHED 状态，服务端收到ACK后也进入ESTABLISHED 状态
为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。

2. TCP断开链接 -》 四次握手
客户端和服务端在断开连接时都需要向对方发送 FIN(FINISH) 和 ACK
1. 客户端 FIN -》 服务端 2. 服务端 ACK -》 客户端 3. 服务端 FIN -》 客户端 4. 客户端 ACK -》 服务端
client：time—await server:close_await

Nagle's algorithm is a means of improving the efficiency of TCP/IP networks by reducing the number of packets that need to be sent over the network

流量控制是为了解决发送方和接收方速度不同而导致的数据丢失问题,当发送方发送的太快,接收方来不及接受就会导致数据丢失,流量控制用滑动窗口的形式解决问题
拥塞控制是为了解决过多的数据注入到网络,导致网络奔溃,超过负荷.当发送方发送数据大量的数据会注入到网络,如果没有限制,网络就会超负荷变卡,拥塞控制的用的是拥塞窗口解决的问题的
拥塞控制机制： 
慢开始和拥塞避免

在浏览器中输入URL后，执行的全部过程
域名解析
在浏览器缓存中查找与域名对应的IP
依次在操作系统，本地域名服务器中寻找。若没有，本地服务器依次向根域名服务器，顶级域名服务器，二级域名服务器发送请求寻找

**********************************************************************************************************************************************************

### hashmap的原理？hashcode和equals的关系？hashcode相等，equals是否相等？ 

Java的基类Object中的 equals()方法用于判断两个对象是否相等，hashCode()方法用于计算对象的哈希码

HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体，以此来解决Hash冲突的问题。
Hashtable是线程安全，而HashMap则非线程安全。

扩容 rehash 2的幂 避免hash冲突 2进制运算快
hashmap index: index = HashCode（Key） & （Length - 1）

为什么hashmap不是线程安全的？
由于put()和putVal()代码没有同步，插入一个value的时候会进行判空处理，在多线程的时候，如果正好2个线程都检查到对应位置是空的，都会插进去的话，先插进去的就会被后插进去的节点覆盖，而不是都挂在后面。就会出现数据错误，导致线程不安全
ConcurrentHashMap具体是怎么实现线程安全的呢，肯定不可能是每个方法加synchronized，那样就变成了HashTable。
从ConcurrentHashMap代码中可以看出，它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。
在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中，每个Segment中的put和get加synchronized

为了平衡空间利用率和hash冲突（效率），设置了一个加载因子(loadFactor)

ArrayList什么时候扩容，几倍？ 满，1.5

ArrayList线程不安全。用Vector Collections.synchronizedList();

**********************************************************************************************************************************************************

### 垃圾回收器 分代回收

### [图解 Java 垃圾回收算法及详细过程](https://xie.infoq.cn/article/9d4830f6c0c1e2df0753f9858)



什么是自动垃圾回收？
自动垃圾回收是一种在堆内存中找出哪些对象在被使用，还有哪些对象没被使用，并且将后者删掉的机制。所谓使用中的对象（已引用对象），指的是程序中有指针指向的对象；而未使用中的对象（未引用对象），则没有被任何指针给指向，因此占用的内存也可以被回收掉。
第一步：标记
第二步：清除+压缩
为什么使用分代垃圾回收?
如前所述，标记并整理所有JVM里的对象，效率是很低的。随着越来越多的对象被分配，对象列表不断增长，导致垃圾回收时间越来越长。然而，根据应用程序的经验分析，大多数的对象都是短命的。
JVM 分代
根据之前的规律，就可以用来提升 JVM 的效率了。方法是，把堆分成几个部分（就是所谓的分代），分别是新生代、老年代，以及永生代。
栈：局部变量
堆：new 对象

**********************************************************************************************************************************************************

### 乐观锁和悲观锁

乐观锁：乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性。

相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本，即在提交数据更新前，进行版本冲突检测。

悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制

synchronized对象锁（针对多线程作用于同一对象）与类锁（针对于同一类的不同对象）：synchronized修饰非静态方法的时候其实获得的是对象实例锁。synchronized修饰代码块的时候，既可以修饰当前对象本身，也可以修饰其他对象。也可以修饰当前class。而synchronized修饰静态方法则是修饰当前class
类锁：synchronized (obj.class)  对象锁：synchronized (this)
**********************************************************************************************************************************************************

### Volatile原理

Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。

当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。

而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。

可见性：可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的
原子性：原子是世界上的最小单位，具有不可分割性
有序性：Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

**********************************************************************************************************************************************************

### 数据库索引

首先明白为什么索引会增加速度，DB在执行一条Sql语句的时候，默认的方式是根据搜索条件进行全表扫描，遇到匹配条件的就加入搜索结果集合。如果我们对某一字段增加索引，查询时就会先去索引列表中一次定位到特定值的行数，大大减少遍历匹配的行数，所以能明显增加查询的速度

数据库为什么使用B+树而不是使用B树
B+树的中间节点只是保存子树的最大数据和子树的子针，本身的占用空间较小，因此可以容纳更多节点元素，也就是说同样数据情况下，B+ 树会 B 树更加“矮胖”，因此查询效率更快。

B+树的优势：
1.单一节点存储更多的元素（这样该节点下分支变多了，树变矮胖了），使得查询的IO次数更少。

2.所有查询都要查找到叶子节点，查询性能稳定。

3.所有叶子节点形成有序链表，便于范围查询。


最左前缀原则
MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。


红黑树就是一种平衡的二叉查找树，说他平衡的意思是他不会变成“瘸子”，左腿特别长或者右腿特别长。
从根到叶子的最长的可能路径不多于最短的可能路径的两倍长
除了符合二叉查找树的特性之外，还具体下列的特性：

1. 节点是红色或者黑色
2. 根节点是黑色
3. 每个叶子的节点都是黑色的空节点（NULL）
4. 每个红色节点的两个子节点都是黑色的。
5. 从任意节点到其每个叶子的所有路径都包含相同的黑色节点。


红黑树和平衡二叉树的区别： 

1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。
2、平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。


操作系统LRU算法

**********************************************************************************************************************************************************

### http有哪些头部？详细介绍一下Cookie。

HTTP Cookie（也叫Web Cookie或浏览器Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie使基于无状态的HTTP协议记录稳定的状态信息成为了可能。

session因为http是无状态协议，服务器是无状态的stateless
cookie 客户端 保存如用户名密码
session 服务端 保存如购物车
**********************************************************************************************************************************************************

HEAD方法跟GET方法相同，只不过服务器响应时不会返回消息体

https对称加密 不对称加密
GET POST区别，POST安全性更高为什么 put和post呢？幂等性

GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST么有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。

接口幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条．．．,这就没有保证接口的幂等性

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源）

PUT是幂等的操作，即重复操作不会产生变化，10次PUT 的创建请求与1次PUT 的创建请求相同，只会创建一个资源，其实后面9次的请求只是对已创建资源的更新，且更新内容与原内容相同，所以不会产生变化。

POST 的重复操作截然不同，10次POST请求将会创建10个资源。

HTTP/2 相比 1.0 有哪些重大改进

二进制传输
多路复用
即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求
HTTP/1.0一次只允许在一个TCP连接上发起一个请求，HTTP/1.1使用的流水线技术也只能部分处理请求并发，仍然会存在队列头阻塞问题，因此客户端在需要发起多次请求时，通常会采用建立多连接来减少延迟。
Header压缩
在HTTP1.0中，我们使用文本的形式传输header，在header中携带cookie的话，每次都需要重复传输几百到几千的字节，这着实是一笔不小的开销
服务器Push
在HTTP2.0中，服务端可以在客户端某个请求后，主动推送其他资源。

IPv4中规定IP地址长度为32，而IPv6中IP地址的长度为128

ping 过程中发生了什么
（1） A主机构建一个ICMP格式的数据包；
（2） ICMP协议+B主机的IP地址 交给IP协议；

ARP：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址(MAC)的一个TCP/IP协议

Http报文结构：
请求报文：请求方法，头，体
响应报文：响应码，头，体


**********************************************************************************************************************************************************

### 进程线程区别

根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

进程优点：每个进程有互相独立的地址空间，不影响主程序的稳定性，子进程崩溃没关系；
缺点：需要跨进程边界，如果有大数据量传送，就不太好，适合小数据量传送、密集运算 多进程调度开销比较大。

线程优点：无需跨进程边界；
缺点：每个线程与主程序共用地址空间，受限于2GB地址空间；

Thread.Sleep(0) 并非是真的要线程挂起0毫秒，意义在于这次调用Thread.Sleep(0)的当前线程确实的被冻结了一下，让其他线程有机会优先执行。Thread.Sleep(0) 是你的线程暂时放弃cpu，也就是释放一些未用的时间片给其他线程或进程使用，就相当于一个让位动作。

### 进程调度算法

先来先服务调度算法 FCFS
时间片轮转调度法
短作业(SJF)优先调度算法
优先级调度算法

### 进程状态

新建
运行
就绪
阻塞
终止
就绪挂起
阻塞挂起

当系统资源尤其是内存资源已经不能满足进程运行的要求时，必须把某些进程挂起（suspend），对换到磁盘对换区中，释放它占有的某些资源，暂时不参与低级调度。起到平滑系统操作负荷的目的。

### 进程间通讯方式

1.管道：速度慢，容量有限，只有父子进程能通讯    
2.FIFO：任何进程间都能通讯，但速度慢    
3.消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题    
4.信号量：不能传递复杂消息，只能用来同步    
5.共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存



### 自旋锁

自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。
自旋锁的优点
自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快

### 计算机组成原理——9种常用寻址方式

1） 隐含寻址
2）立即寻址
3）寄存器直接寻址

4) 寄存器间接寻址
5) 直接寻址
6) 间接寻址
7）相对寻址
8）基址寻址
9) 变址寻址

### CPU中断发生了什么

中断是指在计算机执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的时间处理程序。待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。
当外部中断，需要cpu暂停当前的任务，做相应的处理，cpu需要判断中断源，保存现场状态，以便能够处理完后继续执行中断的任务。

### 改变工作模式至中断模式

保存当前PC（Program Counter 用来存放当前欲执行指令的地址），敏感数据入栈
PC被赋值中断起始地址
CPU跳到中断起始地址处理中断
返回到原来模式
恢复PC，数据出栈，程序继续执行。

协程仅仅是一个特殊的函数，一个进程可以包含多个线程，一个线程可以包含多个协程
**********************************************************************************************************************************************************

### redis 缓存

### 死锁（死锁三连，请没事就问下自己：1.死锁是啥？2.4个条件是啥？3.咋避免？）

死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进
互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）


手写单例模式 Singlton
Lazy initialization with Double check locking: In this mechanism, we overcome the overhead problem of synchronized code. In this method, getInstance is not synchronized but the block which creates instance is synchronized so that minimum number of threads have to wait and that’s only for first time.

public class GFG  
{ 
  // private instance, so that it can be 
  // accessed by only by getInstance() method 
  private static GFG instance; 

  private GFG()  
  { 
    // private constructor 
  } 

  public static GFG getInstance() 
  { 
    if (instance == null)  
    { 
      //synchronized block to remove overhead 
      synchronized (GFG.class) 
      { 
        if(instance==null) 
        { 
          // if instance is null, initialize 
          instance = new GFG(); 
        } 
        
      } 
    } 
    return instance; 
  } 
} 


抽象类和接口的区别






观察者模式
观察者模式（Observer），又叫发布-订阅模式（Publish/Subscribe），定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。UML结构图如下：
public class Subject {

    //观察者数组
    private Vector<Observer> oVector = new Vector<>();
    
    //增加一个观察者
    public void addObserver(Observer observer) {
        this.oVector.add(observer);
    }
    
    //删除一个观察者
    public void deleteObserver(Observer observer) {
        this.oVector.remove(observer);
    }
    
    //通知所有观察者
    public void notifyObserver() {
        for(Observer observer : this.oVector) {
            observer.update();
        }
    }
    
    public void doSomething() {
    	setAction()
    	nofifyObserver()
    }
    
    public void setAction(String action);
    public String getAction();

}

public class ConcreteObserver implements Observer {

	public ConcreteObserver(Subject subject)
	{
		super(subject);
	} 
	@Override
	public void update() {
	    System.out.println(subject.getAction() + "收到消息，进行处理");
	}

}

虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换

StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有公开方法都是 synchronized 修饰的，而 StringBuilder 并没有 synchronized 修饰。