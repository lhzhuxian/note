## 224 Basic Calculator

实现 + - （） 

```java
class Solution {
    public int calculate(String s) {
        Queue<Character> q = new ArrayDeque<>();
        for(char c : s.toCharArray()) {
            if(c != ' ') {
                q.offer(c);
            }
        }
        return helper(q);
    }
    private int helper(Queue<Character> q) {
        int num = 0, sum = 0, sign = 1;
        while(!q.isEmpty()) {
            char c = q.poll();
            if(Character.isDigit(c)) {
                num = num * 10 + c - '0';
            } else if(c == '(') {
                num = helper(q);
            } else if(c == ')') {
                break;
            }else {
                sum += sign * num;
                if(c == '+') sign = 1;
                if(c == '-') sign = -1;
                num = 0;
            }
        }
        return sum += sign * num;
    }
}
```





## 227 Basic Calculator II

Given a string `s` which represents an expression, *evaluate this expression and return its value*. 

The integer division should truncate toward zero.

**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.

**Example 1:**

```
Input: s = "3+2*2"
Output: 7
```

**Example 2:**

```
Input: s = " 3/2 "
Output: 1
```

**Example 3:**

```
Input: s = " 3+5 / 2 "
Output: 5
```

**Solution**

不需要把 + - 给放入stack 中，直接放正负数就行了

```java
class Solution {
    public int calculate(String s) {

        if (s == null || s.isEmpty()) return 0;
        int len = s.length();
        Stack<Integer> stack = new Stack<Integer>();
        int currentNumber = 0;
        char operation = '+';
        for (int i = 0; i < len; i++) {
            char currentChar = s.charAt(i);
            if (Character.isDigit(currentChar)) {
                currentNumber = (currentNumber * 10) + (currentChar - '0');
            }
            if (!Character.isDigit(currentChar) && !Character.isWhitespace(currentChar) || i == len - 1) {
                if (operation == '-') {
                    stack.push(-currentNumber);
                }
                else if (operation == '+') {
                    stack.push(currentNumber);
                }
                else if (operation == '*') {
                    stack.push(stack.pop() * currentNumber);
                }
                else if (operation == '/') {
                    stack.push(stack.pop() / currentNumber);
                }
                operation = currentChar;
                currentNumber = 0;
            }
        }
        int result = 0;
        while (!stack.isEmpty()) {
            result += stack.pop();
        }
        return result;
    }
}
```



## 772 Basic Calculator III

Implement a basic calculator to evaluate a simple expression string.

The expression string contains only non-negative integers, `'+'`, `'-'`, `'*'`, `'/'` operators, and open `'('` and closing parentheses `')'`. The integer division should **truncate toward zero**.

You may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`.

**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.



**Solution**

这题就是这个系列的终极版

思路就是延迟计算，每次都是我们有两个数的时候在开始计算prevOP, 因为有乘除这个更高的优先级

```Java
class Solution {
    public int calculate(String s) {
        Queue<Character> q = new ArrayDeque<>();
        for(char c : s.toCharArray()) {
            if(c != ' ') {
                q.offer(c);
            }
        }
        q.offer(' ');
        return helper(q);
    }
    
    private int helper(Queue<Character> q) {
        
        // prev prevop num
        int num = 0, prev = 0, sum = 0;
        char prevOp = '+';
        while(!q.isEmpty()) {
            char c = q.poll();
            if(Character.isDigit(c)) {
                num = num * 10 + c - '0';
            } else if(c == '(') {
                num = helper(q);
            } else {
                switch(prevOp) {
                    case '+':
                        sum += prev;
                        prev = num;
                        break;
                    case '-':
                        sum += prev;
                        prev = -num;
                        break;
                    case '*':
                        prev *= num;
                        break;
                    case '/':
                        prev /= num;
                        break;
                }
                
                if(c == ')') break;
                prevOp = c;
                num = 0;
                
            }
        }
        return sum + prev;
    }
}
```

