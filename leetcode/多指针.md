## 基本问题

（1）多指针是一个非常广泛的概念，并不是一个固定的算法。但基本上是通过一些变量的控制与循环把问题的复杂度控制在一两层for循环之内。可以用在数组、链表、区间、滑动窗口、流、回文串、和差问题等多个场景。（前项和其实并不完全是指针问题，但也归并在这里）。
（2）Quick Sort和Merge Sort的基本原理与实现，排序的稳定性问题
（3）Quick Select的实现与复杂度
（4）同向指针与相向指针的使用场景
（5）不同场景下循环终止条件？
（6）两数之和，之差，特定条件下（大小于某值等）的计数问题
（7）三数或三数以上之和的通用写法（两数之和+搜索）
（8）数组有没有排序？是否需要排序？
（9）数组有没有去重？是否需要去重？
（10）离线数据（内存中，有限长）还是在线数据（无法放入内存，长度未知）？
（11）链表操作中dummy node与previous node的使用技巧
（12）链表的中点，判断是否有环，寻找环的交叉点



## 数组

![](../static/Screen Shot 2021-06-03 at 07.17.27.png)

### Follow up

 Could you come up with a one-pass algorithm using only constant extra space?

### Solution

1. 双指针，一个来track 0 的index， 另外一个track 2 的index
2. loop 整个array，将0 swap到数组前端，将2 swap到数组后端
3. time: O(N), space: O(1)

```
class Solution {
    public void sortColors(int[] nums) {
        if(nums == null && nums.length == 0) {
            return;
        }
        int zeroIndex = 0;
        int twoIndex = nums.length - 1;
        int i = 0;
        while(i <= twoIndex) {
            int cur = nums[i];
            if(cur == 0) {
                swap(nums, i, zeroIndex);
                zeroIndex++;
                
            } else if(cur == 2) {
                swap(nums, i, twoIndex);
                twoIndex--;
            } 
            i++;
        }
        
    }
    
    private void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
}
```

![](../static/Screen Shot 2021-06-08 at 07.30.58.png)

### Solution

1. using two pointer, i is used to reference the real index, j is used to loop the array
2. while nuns[j] is not equal to nums[i], we can put that into the real array
3. time: O(N), space: O(1)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;
        int i = 0;
        for (int j = 1; j < nums.length; j++) {
            if (nums[j] != nums[i]) {
                i++;
                nums[i] = nums[j];
            }
        }
        return i + 1;
    }
}
```

![](../static/Screen Shot 2021-06-08 at 07.37.24.png)

### Solution

1. 本质和leetcode26  Remove Duplicates from Sorted Array 相同
2. 需要另外的一个count 来记一下重复的次数
3. time: O(N), space: O(1)

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length == 0) return 0;
        int i = 0;
        int count = 1;
        for(int j = 1; j < nums.length; ++j) {
            if(nums[j] != nums[i]) {
                i++;
                nums[i] = nums[j];
                count = 1;
            } else if(count == 1) {
                i++;
                nums[i] = nums[j];
                count++;
            }
        }
        return i + 1;
    }
}
```

![](../static/Screen Shot 2021-06-08 at 07.44.49.png)

### Solution

1. 从后往前排序
2. time: O(N), space:O(1)

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p = nums1.length - 1;
        int p1 = m - 1;
        int p2 = n - 1;
        while(p >= 0) {
            if(p1 < 0) {
                nums1[p] = nums2[p2];
                p2--;
            } else if(p2 < 0) {
                nums1[p] = nums1[p1];
                p1--;
            } else if(nums1[p1] > nums2[p2]) {
                nums1[p] = nums1[p1];
                p1--;
            } else {
                nums1[p] = nums2[p2];
                p2--;
            }
            p--;
        }
    }
}
```

![](../static/Screen Shot 2021-06-08 at 07.51.02.png)

### Solution

1. 类似leetcode26
2. 最后把后面的零补全

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int count = 0;
        for (int i = 0; i < nums.length; ++i) {
            if(nums[i] != 0) {
                nums[count] = nums[i];
                count++;
            } 
        }
        for(int i = count; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}
```

