# 基本问题

（1）理解二叉树、平衡二叉树、二叉搜索树的关系和概念。
（2）理解递归的概念和方法，递归三要素。
（3）在解决递归问题的时候，有时可以返回多个值（Python），或者用一个额外的class包装多个值（Java）。
（4）熟练掌握用递归和非递归的方式分别前序、中序、后序遍历二叉树的方法。
（5）理解掌握分治和遍历的区别和联系。
（6）理解掌握top-down, buttom-up的思路。
（7）理解掌握二叉树上的Iterator。


二叉树与递归 题目列表：
（必背：紫色；核心：蓝色；重点：绿色；普通：黄色；默认是LeetCode，如果是LintCode会以Lint开头）

因为二叉树上的递归很多时候既可以用分治，也可以用遍历，并不是哪一种方法总能最优。
所以我们按相似题目分类，而不是按解法分类。

# 二叉树遍历（需要熟练掌握非递归方式）：



## Binary Tree Traversal

**Solution**

```java
// inorder traversal
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
       List<Integer> result = new ArrayList<Integer>();
       traversalHelper(root, result);
        return result;
    }
    public void traversalHelper(TreeNode root, List<Integer> result) {
        if(root == null) {
            return;
        }
        traversalHelper(root.left, result);
        result.add(root.val);
        traversalHelper(root.right, result);
    }
}
// preorder traversal
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        traversalHelper(root, result);
        return result;
    }
    public void traversalHelper(TreeNode root, List<Integer> result) {
        if(root == null) {
            return;
        }
        result.add(root.val);
        traversalHelper(root.left, result);
        traversalHelper(root.right, result);
    }
}
//postorder traversal
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<Integer>();
        traversalHelper(root, result);
        return result;
    }
    
        public void traversalHelper(TreeNode root, List<Integer> result) {
        if(root == null) {
            return;
        }
        traversalHelper(root.left, result);
        traversalHelper(root.right, result);
        result.add(root.val);
    }
}
```





## Binary Tree Vertical Order Traversal

Given the `root` of a binary tree, return ***the vertical order traversal** of its nodes' values*. (i.e., from top to bottom, column by column).

If two nodes are in the same row and column, the order should be from **left to right**.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/28/vtree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/01/28/vtree2-1.jpg)

```
Input: root = [3,9,8,4,0,1,7]
Output: [[4],[9],[3,0,1],[8],[7]]
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2021/01/28/vtree2.jpg)

```
Input: root = [3,9,8,4,0,1,7,null,null,null,2,5]
Output: [[4],[9,5],[3,0,1],[8,2],[7]]
```

**Example 4:**

```
Input: root = []
Output: []
```

**Solution**

下次看到要练一下写

```java
class Solution {
  public List<List<Integer>> verticalOrder(TreeNode root) {
    List<List<Integer>> output = new ArrayList();
    if (root == null) {
      return output;
    }

    Map<Integer, ArrayList> columnTable = new HashMap();
    // Pair of node and its column offset
    Queue<Pair<TreeNode, Integer>> queue = new ArrayDeque();
    int column = 0;
    queue.offer(new Pair(root, column));

    int minColumn = 0, maxColumn = 0;

    while (!queue.isEmpty()) {
      Pair<TreeNode, Integer> p = queue.poll();
      root = p.getKey();
      column = p.getValue();

      if (root != null) {
        if (!columnTable.containsKey(column)) {
          columnTable.put(column, new ArrayList<Integer>());
        }
        columnTable.get(column).add(root.val);
        minColumn = Math.min(minColumn, column);
        maxColumn = Math.max(maxColumn, column);

        queue.offer(new Pair(root.left, column - 1));
        queue.offer(new Pair(root.right, column + 1));
      }
    }

    for(int i = minColumn; i < maxColumn + 1; ++i) {
      output.add(columnTable.get(i));
    }

    return output;
  }
}
```





## 987 Vertical Order Traversal of a Binary Tree

Given the `root` of a binary tree, calculate the **vertical order traversal** of the binary tree.

For each node at position `(row, col)`, its left and right children will be at positions `(row + 1, col - 1)` and `(row + 1, col + 1)` respectively. The root of the tree is at `(0, 0)`.

The **vertical order traversal** of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column. There may be multiple nodes in the same row and same column. In such a case, sort these nodes by their values.

Return *the **vertical order traversal** of the binary tree*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[9],[3,15],[20],[7]]
Explanation:
Column -1: Only node 9 is in this column.
Column 0: Nodes 3 and 15 are in this column in that order from top to bottom.
Column 1: Only node 20 is in this column.
Column 2: Only node 7 is in this column.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/01/29/vtree2.jpg)

```
Input: root = [1,2,3,4,5,6,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
Column -2: Only node 4 is in this column.
Column -1: Only node 2 is in this column.
Column 0: Nodes 1, 5, and 6 are in this column.
          1 is at the top, so it comes first.
          5 and 6 are at the same position (2, 0), so we order them by their value, 5 before 6.
Column 1: Only node 3 is in this column.
Column 2: Only node 7 is in this column.
```

**Example 3:**

![img](https://assets.leetcode.com/uploads/2021/01/29/vtree3.jpg)

```
Input: root = [1,2,3,4,6,5,7]
Output: [[4],[2],[1,5,6],[3],[7]]
Explanation:
This case is the exact same as example 2, but with nodes 5 and 6 swapped.
Note that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.
```

 **Solution**

```java
class Solution {
    Map<Integer, ArrayList<Pair<Integer, Integer>>> columnTable = new HashMap();
    int minColumn = 0, maxColumn = 0;

    private void DFS(TreeNode node, Integer row, Integer column) {
        if (node == null)
            return;

        if (!columnTable.containsKey(column)) {
            this.columnTable.put(column, new ArrayList<Pair<Integer, Integer>>());
        }

        this.columnTable.get(column).add(new Pair<Integer, Integer>(row, node.val));
        this.minColumn = Math.min(minColumn, column);
        this.maxColumn = Math.max(maxColumn, column);
        // preorder DFS traversal
        this.DFS(node.left, row + 1, column - 1);
        this.DFS(node.right, row + 1, column + 1);
    }

    public List<List<Integer>> verticalTraversal(TreeNode root) {
        List<List<Integer>> output = new ArrayList();
        if (root == null) {
            return output;
        }

        // step 1). DFS traversal
        this.DFS(root, 0, 0);

        // step 2). retrieve the value from the columnTable
        for (int i = minColumn; i < maxColumn + 1; ++i) {
            // order by both "row" and "value"
            Collections.sort(columnTable.get(i), (p1, p2) -> {
                if (p1.getKey().equals(p2.getKey()))
                        return p1.getValue() - p2.getValue();
                    else
                        return p1.getKey() - p2.getKey();
            });

            List<Integer> sortedColumn = new ArrayList();
            for (Pair<Integer, Integer> p : columnTable.get(i)) {
                sortedColumn.add(p.getValue());
            }
            output.add(sortedColumn);
        }

        return output;
    }
}
```



# 反向复原二叉树

105. Construct Binary Tree from Preorder and Inorder Traversal
https://leetcode.com/problems/co ... -inorder-traversal/

106. Construct Binary Tree from Inorder and Postorder Traversal
https://leetcode.com/problems/co ... ostorder-traversal/

889. Construct Binary Tree from Preorder and Postorder Traversal
https://leetcode.com/problems/co ... ostorder-traversal/

## 536 Construct Binary Tree from String

You need to construct a binary tree from a string consisting of parenthesis and integers.

The whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root's value and a pair of parenthesis contains a child binary tree with the same structure.

You always start to construct the **left** child node of the parent first if it exists.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/02/butree.jpg)

```
Input: s = "4(2(3)(1))(6(5))"
Output: [4,2,6,3,1,5]
```

**Example 2:**

```
Input: s = "4(2(3)(1))(6(5)(7))"
Output: [4,2,6,3,1,5,7]
```

**Example 3:**

```
Input: s = "-4(2(3)(1))(6(5)(7))"
Output: [-4,2,6,3,1,5,7]
```

**Solution**

```java
public class Solution {
    public TreeNode str2tree(String s) {
        Stack<TreeNode> stack = new Stack<>();
        for(int i = 0; i < s.length();) {
            char cur = s.charAt(i);
            if(cur == ')') {
                stack.pop();
                i++;
              // corner case 是负数的情况
            } else if(cur == '-' || Character.isDigit(cur)) {
                int j = i + 1;
                while(j < s.length() && Character.isDigit(s.charAt(j))) {
                    j++;
                }
                int val = Integer.valueOf(s.substring(i, j));
                TreeNode node = new TreeNode(val);
                if(!stack.isEmpty()) {
                    TreeNode parent = stack.peek();
                    if(parent.left == null) {
                        parent.left = node;
                    } else {
                        parent.right = node;
                    }
                }
                stack.push(node);
                i = j;
            } else {
              // 避免死循环
                i++;
            }
        }
        return stack.isEmpty() ? null : stack.peek();
    }
}
```





# Iterator相关

## Binary Search Tree Iterator

Implement the `BSTIterator` class that represents an iterator over the **[in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR))** of a binary search tree (BST):

- `BSTIterator(TreeNode root)` Initializes an object of the `BSTIterator` class. The `root` of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.
- `boolean hasNext()` Returns `true` if there exists a number in the traversal to the right of the pointer, otherwise returns `false`.
- `int next()` Moves the pointer to the right, then returns the number at the pointer.

Notice that by initializing the pointer to a non-existent smallest number, the first call to `next()` will return the smallest element in the BST.

You may assume that `next()` calls will always be valid. That is, there will be at least a next number in the in-order traversal when `next()` is called.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png)

```
Input
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
Output
[null, 3, 7, true, 9, true, 15, true, 20, false]

Explanation
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // return 3
bSTIterator.next();    // return 7
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 9
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 15
bSTIterator.hasNext(); // return True
bSTIterator.next();    // return 20
bSTIterator.hasNext(); // return False
```



230. Kth Smallest Element in a BST
https://leetcode.com/problems/kth-smallest-element-in-a-bst/

285. Inorder Successor in BST
https://leetcode.com/problems/inorder-successor-in-bst/

270. Closest Binary Search Tree Value
https://leetcode.com/problems/closest-binary-search-tree-value/

272. Closest Binary Search Tree Value II
https://leetcode.com/problems/cl ... arch-tree-value-ii/

510. Inorder Successor in BST II
https://leetcode.com/problems/inorder-successor-in-bst-ii/

Lint-915. Inorder Predecessor in BST II
https://www.lintcode.com/problem ... -in-bst/description



# 对树做变形



## Delete Node in a BST

Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

1. Search for a node to remove.
2. If the node is found, delete the node.

**Follow up:** Can you solve it with time complexity `O(height of tree)`?

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg)

```
Input: root = [5,3,6,2,4,null,7], key = 3
Output: [5,4,6,2,null,null,7]
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it.
One valid answer is [5,4,6,2,null,null,7], shown in the above BST.
Please notice that another valid answer is [5,2,6,null,4,null,7] and it's also accepted.
```

**Example 2:**

```
Input: root = [5,3,6,2,4,null,7], key = 0
Output: [5,3,6,2,4,null,7]
Explanation: The tree does not contain a node with value = 0.
```

**Example 3:**

```
Input: root = [], key = 0
Output: []
```

**Solution**

BST的基本操作，但要写的没毛病还是需要点功夫

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        TreeNode prev = null, target = root;
        while(target != null && target.val != key) {
            prev = target;
          // 这个地方一定要用if else 要不然很容易下面那个if出 null pointer错误
            if(key < target.val) { 
                target = target.left;
            } else {
                target = target.right;
            }
        }
        
        if(target == null) {
            return root;
        }
        TreeNode next = mergeChildren(target.left, target.right);
        
        if(prev != null) {
            if(prev.val > target.val) prev.left = next;
            if(prev.val < target.val) prev.right = next;
        } else {
            root = next;
        }
        return root;
    }
    
    public TreeNode mergeChildren(TreeNode left, TreeNode right) {
      // 把left 接到right的最左边
        if(left == null) {
            return right;
        } else if(right == null) {
            return left;
        } else {
            TreeNode cur = right;
            while(cur.left != null) {
                cur = cur.left;
            }
            cur.left = left;
            return right;
        }
    }
}
```



## Binary Tree Upside Down

Given the `root` of a binary tree, turn the tree upside down and return *the new root*.

You can turn a binary tree upside down with the following steps:

1. The original left child becomes the new root.
2. The original root becomes the new right child.
3. The original right child becomes the new left child.

![img](https://assets.leetcode.com/uploads/2020/08/29/main.jpg)

The mentioned steps are done level by level, it is **guaranteed** that every node in the given tree has either **0 or 2 children**.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/08/29/updown.jpg)

```
Input: root = [1,2,3,4,5]
Output: [4,5,2,null,null,3,1]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

**Solution**

很难理解，下次复习的时候看看能不能想起来

**Binary Tree** 右子树不用去考虑

**Iterative的方法下次看要再做一遍**

```java
class Solution {
    public TreeNode upsideDownBinaryTree(TreeNode root) {
      if(root == null || root.left == null) {
          return root;
      }
      // new root 就是最左边的那个点
      TreeNode newRoot = upsideDownBinaryTree(root.left);
      root.left.left = root.right;   // node 2 left children
      root.left.right = root;         // node 2 right children
      root.left = null;
      root.right = null;
      return newRoot;
  }
}

class Solution {
 public TreeNode upsideDownBinaryTree(TreeNode root) {
    TreeNode curr = root;
    TreeNode next = null;
    TreeNode temp = null;
    TreeNode prev = null;
    
    while(curr != null) {
        next = curr.left;
        
        // swapping nodes now, need temp to keep the previous right child
        curr.left = temp;
        temp = curr.right;
        curr.right = prev;
        
        prev = curr;
        curr = next;
    }
    return prev;
}  
}
```





## 426 Convert Binary Search Tree to Sorted Doubly Linked List

Convert a **Binary Search Tree** to a sorted **Circular Doubly-Linked List** in place.

You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.

We want to do the transformation **in place**. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.

 **Example 1:**

![img](https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png)

```
Input: root = [4,2,5,1,3]


Output: [1,2,3,4,5]

Explanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.
```

**Example 2:**

```
Input: root = [2,1,3]
Output: [1,2,3]
```

**Example 3:**

```
Input: root = []
Output: []
Explanation: Input is an empty tree. Output is also an empty Linked List.
```

**Example 4:**

```
Input: root = [1]
Output: [1]
```

**Solution**

```java
class Solution {
    public Node treeToDoublyList(Node root) {
        if(root == null) {
            return null;
        }
        Node head = new Node();
        Node tail = dfs(head, root);
        tail.right = head.right;
        head.right.left = tail;
        return head.right;
    }
    
    private Node dfs(Node tail, Node root) {
        if(root == null) {
            return tail;
        }
        tail = dfs(tail, root.left);
        tail.right = root;
        root.left = tail;
        return dfs(root,root.right);
    }
}
```



# 判断树的形态



## Graph Valid Tree

You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer n and a list of `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi` in the graph.

Return `true` *if the edges of the given graph make up a valid tree, and* `false` *otherwise*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/12/tree1-graph.jpg)

```
Input: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]
Output: true
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/03/12/tree2-graph.jpg)

```
Input: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]
Output: false
```

 

**Solution**

**Binary tree** **dfs**

是否是tree，需要没有环，且每个点都连通

```java
class Solution {
    public boolean validTree(int n, int[][] edges) {
        // build graph
        Map<Integer, List<Integer> > graph = new HashMap<>();
        for(int i = 0; i < n; ++i) {
            graph.put(i, new ArrayList<>());
        }    
        for(int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        
        // dfs to make sure there is no circle
        boolean[] visited = new boolean[n];
        if(isCircleExist(0, -1, graph, visited)) {
            return false;
        }
        
        // 每个点都必须要连着
        for(int i = 0; i < n; ++i) {
            if(visited[i] == false) {
                return false;
            }
        }
        
        return true;
    }
    
    public boolean isCircleExist(int cur, int parent, Map<Integer, List<Integer> > graph, boolean[] visited) {
        // base case
        if(visited[cur] == true) {
            // find circle
            return true;
        }
        visited[cur] = true;
        for(int next : graph.get(cur)) {
            if(next != parent) {
                if(isCircleExist(next, cur, graph, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    
}
```



98. Validate Binary Search Tree
https://leetcode.com/problems/validate-binary-search-tree/

100. Same Tree
https://leetcode.com/problems/same-tree/

110. Balanced Binary Tree
https://leetcode.com/problems/balanced-binary-tree/

------



## Symmetric Tree

Given the `root` of a binary tree, *check whether it is a mirror of itself* (i.e., symmetric around its center).

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

```
Input: root = [1,2,2,3,4,4,3]
Output: true
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

```
Input: root = [1,2,2,null,3,null,3]
Output: false
```

 **Solution**

简单的backtracking 对称那等于 左子树 和 右子树对称

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
      if(root == null) {
          return true;
      }
      return isSymmetricHelper(root.left, root.right);
    }
    
    public boolean isSymmetricHelper(TreeNode left, TreeNode right) {
       if(left == null && right == null) {
           return true;
       } else if(left != null && right == null) {
           return false;
       } else if(right != null && left == null) {
           return false;
       } else if(left.val != right.val) {
           return false;
       }
       return isSymmetricHelper(left.left, right.right) && isSymmetricHelper(left.right, right.left);
    }
}
```

------

## Find Leaves of Binary Tree

Given the `root` of a binary tree, collect a tree's nodes as if you were doing this:

- Collect all the leaf nodes.
- Remove all the leaf nodes.
- Repeat until the tree is empty. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/16/remleaves-tree.jpg)

```
Input: root = [1,2,3,4,5]
Output: [[4,5,3],[2],[1]]
Explanation:
[[3,5,4],[2],[1]] and [[3,4,5],[2],[1]] are also considered correct answers since per each level it does not matter the order on which elements are returned.
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Solution**

**二叉树 recursion dfs** 只要把每个点的depth记录下来，然后组合成答案就可以了 

用bfs记录depth也可以

```java
class Solution {
    public List<List<Integer>> findLeaves(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        Map<TreeNode, Integer> map = new HashMap<>(); 
        int totalDepth = dfs(root, map);
        for(int i = 0; i < totalDepth; ++i) {
            result.add(new ArrayList<>());
        }
        for(TreeNode node : map.keySet()) {
            result.get(map.get(node) - 1).add(node.val);
        }
        return result;
    }
    
    public int dfs(TreeNode root, Map<TreeNode, Integer> map) {
        if(root == null) {
            return 0;
        }
        int depth = Math.max(dfs(root.left, map), dfs(root.right, map)) + 1;
        map.put(root, depth);
        return depth;
    }
}
```



# 子树相关问题

111. Minimum Depth of Binary Tree
https://leetcode.com/problems/minimum-depth-of-binary-tree/

104. Maximum Depth of Binary Tree
https://leetcode.com/problems/maximum-depth-of-binary-tree/

333. Largest BST Subtree
https://leetcode.com/problems/largest-bst-subtree/

Lint-596. Minimum Subtree
https://www.lintcode.com/problem/minimum-subtree/description

Lint-597. Subtree with Maximum Average
https://www.lintcode.com/problem ... average/description





## 938 Range Sum of BST

Given the `root` node of a binary search tree and two integers `low` and `high`, return *the sum of values of all nodes with a value in the **inclusive** range* `[low, high]`. 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg)

```
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15
Output: 32
Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg)

```
Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
Output: 23
Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23.
```

**Solution**

```java
class Solution {
    public int rangeSumBST(TreeNode root, int low, int high) {
        return dfs(root, 0, low, high);
    }
    
    public int dfs(TreeNode root, int curSum, int low, int high) {
        if(root == null) {
            return curSum;
        }
        
        if(root.val >= low && root.val <= high) {
            curSum += root.val;
        }
        if(root.val >= low) curSum = dfs(root.left, curSum, low, high);
        if(root.val <= high) curSum = dfs(root.right, curSum, low, high);
        return curSum; 
    }
}
```



------



## Maximum Depth of Binary Tree

Given the `root` of a binary tree, return *its maximum depth*.

A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

```
Input: root = [3,9,20,null,null,15,7]
Output: 3
```

**Example 2:**

```
Input: root = [1,null,2]
Output: 2
```

**Example 3:**

```
Input: root = []
Output: 0
```

**Example 4:**

```
Input: root = [0]
Output: 1
```

**Solution**

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) {
            return 0;
        }
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```



## Second Minimum Node In a Binary Tree

Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly `two` or `zero` sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property `root.val = min(root.left.val, root.right.val)` always holds.

Given such a binary tree, you need to output the **second minimum** value in the set made of all the nodes' value in the whole tree.

If no such second minimum value exists, output -1 instead.  

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg)

```
Input: root = [2,2,5,null,null,5,7]
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg)

```
Input: root = [2,2,2]
Output: -1
Explanation: The smallest value is 2, but there isn't any second smallest value.
```

**Solution**

**Binary Tree** 

这个题目brutal force就直接遍历所有的点，然后找到第二大的点。 这个tree的特性可以帮我们做一些减枝。root的val就是这个tree最小的值，所以只要root的val比当前的最小值大，就没有必要往下看了。

dfs 的space complexity 是longest path

```java
class Solution {
    int min;
    int ans;
    public int findSecondMinimumValue(TreeNode root) {
        if(root == null) {
            return -1;
        }
        min = root.val;
        ans = -1;
        dfs(root);
        return ans;
    }
    
    public void dfs(TreeNode root) {
        if(root == null) {
            return;
        }
        if(ans == -1 && root.val > min) {
            ans = root.val;
        } else if (root.val > min && root.val < ans) {
            ans = root.val;
        } else if(min == root.val) {
            dfs(root.left);
            dfs(root.right);
        }
    }
}
```





------



## Closest Binary Search Tree Value II

Given the `root` of a binary search tree, a `target` value, and an integer `k`, return *the* `k` *values in the BST that are closest to the* `target`. You may return the answer in **any order**.

You are **guaranteed** to have only one unique set of `k` values in the BST that are closest to the `target`.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/12/closest1-1-tree.jpg)

```
Input: root = [4,2,5,1,3], target = 3.714286, k = 2
Output: [4,3]
```

**Example 2:**

```
Input: root = [1], target = 0.000000, k = 1
Output: [1]
```

**Solution**

The idea is compare the part that smaller than target and the larger part. We can use **two stack** to track these two parts. inorder traversal will give us the acending order and the reverse version of inorder traversal will give us the descending order.

```java
class Solution {
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
          List<Integer> res = new ArrayList<>();

        Stack<Integer> s1 = new Stack<>(); // predecessors
        Stack<Integer> s2 = new Stack<>(); // successors

        inorder(root, target, false, s1);
        inorder(root, target, true, s2);

        while (k-- > 0) {
        if (s1.isEmpty())
          res.add(s2.pop());
        else if (s2.isEmpty())
          res.add(s1.pop());
        else if (Math.abs(s1.peek() - target) < Math.abs(s2.peek() - target))
          res.add(s1.pop());
        else
          res.add(s2.pop());
        }

        return res;
    }
    
    private void inorder (TreeNode root, double target, boolean reverse, Stack<Integer> stack) {
        if(root == null) {
            return;
        }
        inorder(reverse ? root.right:root.left, target, reverse, stack);
        // early terminate, we only need the part that is smaller than target or larger than target
        if((reverse && root.val <= target) || (!reverse && root.val > target)) {
            return;
        }
        stack.push(root.val);
        inorder(reverse ? root.left:root.right, target, reverse, stack);
    }
}
```





# 路径相关问题



## 863 All Nodes Distance K in Binary Tree

Given the `root` of a binary tree, the value of a target node `target`, and an integer `k`, return *an array of the values of all nodes that have a distance* `k` *from the target node.*

You can return the answer in **any order**.

 

**Example 1:**

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2
Output: [7,4,1]
Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.
```

**Example 2:**

```
Input: root = [1], target = 1, k = 3
Output: []
```

**Solution**

就是用bfs找到k distance能到的所有点，要完善这个graph 我们需要找到 node to parent的关系

```java
class Solution {
    Map<TreeNode, TreeNode> parent;
    public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
        parent = new HashMap();
        dfs(root, null);

        Queue<TreeNode> queue = new LinkedList();
        queue.add(null);
        queue.add(target);

        Set<TreeNode> seen = new HashSet();
        seen.add(target);
        seen.add(null);

        int dist = 0;
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node == null) {
                if (dist == K) {
                    List<Integer> ans = new ArrayList();
                    for (TreeNode n: queue)
                        ans.add(n.val);
                    return ans;
                }
                queue.offer(null);
                dist++;
            } else {
                if (!seen.contains(node.left)) {
                    seen.add(node.left);
                    queue.offer(node.left);
                }
                if (!seen.contains(node.right)) {
                    seen.add(node.right);
                    queue.offer(node.right);
                }
                TreeNode par = parent.get(node);
                if (!seen.contains(par)) {
                    seen.add(par);
                    queue.offer(par);
                }
            }
        }

        return new ArrayList<Integer>();
    }

    public void dfs(TreeNode node, TreeNode par) {
        if (node != null) {
            parent.put(node, par);
            dfs(node.left, node);
            dfs(node.right, node);
        }
    }
}
```







## 112 Path Sum

Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a **root-to-leaf** path such that adding up all the values along the path equals `targetSum`.

A **leaf** is a node with no children.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)

```
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

```
Input: root = [1,2,3], targetSum = 5
Output: false
```

**Example 3:**

```
Input: root = [1,2], targetSum = 0
Output: false
```

**Solution**

dfs traversal 可以用stack 来进行iterateive

```java
class Solution {
    
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if(root == null) {
            return false;
        }        
        
        Stack<TreeNode> node_stack = new Stack();
        Stack<Integer> sum_stack = new Stack();
        
        node_stack.add(root);
        sum_stack.add(targetSum-root.val);
        while(!node_stack.isEmpty()) {
            TreeNode node = node_stack.pop();
            int sum = sum_stack.pop();
            if(node.right == null && node.left == null && sum == 0) {
                return true;
            }
            
            if(node.right != null) {
                node_stack.add(node.right);
                sum_stack.add(sum - node.right.val);
            }
            if(node.left != null) {
                node_stack.add(node.left);
                sum_stack.add(sum - node.left.val);
            }
            
        }
        return false;
    }
    

}
```



1. Path Sum
   https://leetcode.com/problems/path-sum/
2. Path Sum II
   https://leetcode.com/problems/path-sum-ii/
3. Binary Tree Maximum Path Sum
   https://leetcode.com/problems/binary-tree-maximum-path-sum/

Lint-475. Binary Tree Maximum Path Sum II
https://www.lintcode.com/problem ... -sum-ii/description

298. Binary Tree Longest Consecutive Sequence
https://leetcode.com/problems/bi ... nsecutive-sequence/

549. Binary Tree Longest Consecutive Sequence II
https://leetcode.com/problems/bi ... cutive-sequence-ii/

Lint-619. Binary Tree Longest Consecutive Sequence III
https://www.lintcode.com/problem ... nce-iii/description



## 124 Binary Tree Maximum Path Sum

A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.

The **path sum** of a path is the sum of the node's values in the path.

Given the `root` of a binary tree, return *the maximum **path sum** of any path*.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg)

```
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg)

```
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.
```

**Solution**

试一试用bfs来做

```java
class Solution {
    int maxSum;
    public int maxPathSum(TreeNode root) {
        maxSum = Integer.MIN_VALUE;
        dfs(root);
        return maxSum;
    }
    
    public int dfs(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int leftMaxSum = dfs(root.left);
        int rightMaxSum = dfs(root.right);
        maxSum = Math.max(maxSum, root.val);
        maxSum = Math.max(maxSum, root.val + leftMaxSum);
        maxSum = Math.max(maxSum, root.val + rightMaxSum);
        maxSum = Math.max(maxSum, root.val + rightMaxSum + leftMaxSum);
        
        int singlePathSum = Math.max(root.val + leftMaxSum, root.val + rightMaxSum);
        return Math.max(root.val, singlePathSum);
        
    }
}
```









## 543 Diameter of Binary Tree

Given the `root` of a binary tree, return *the length of the **diameter** of the tree*.

The **diameter** of a binary tree is the **length** of the longest path between any two nodes in a tree. This path may or may not pass through the `root`.

The **length** of a path between two nodes is represented by the number of edges between them.

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
```

**Example 2:**

```
Input: root = [1,2]
Output: 1
```

**Solution**

```java
class Solution {
    int result;
    public int diameterOfBinaryTree(TreeNode root) {
        result = 0;
        dfs(root);
        return result;
    }
    
    private int dfs(TreeNode root) {
        if(root == null) {
            return 0;
        }
        int rightDepth = dfs(root.right);
        int leftDepth = dfs(root.left);
        result = Math.max(result, rightDepth + leftDepth);
        return Math.max(rightDepth, leftDepth) + 1;
    }
}
```





# LCA问题

## Lowest Common Ancestor of a Binary Tree

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```java
Input: root = [1,2], p = 1, q = 2
Output: 1
```

**Solution**

```java
class Solution {
    TreeNode result;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;
        dfs(root, p, q);
        return result;
    }
    
    public boolean dfs(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) {
            return false;
        }
        boolean left = dfs(root.left, p, q);
        boolean right = dfs(root.right, p, q);
        if(root.val == p.val || root.val == q.val) {
            if(left || right) {
              result = root;
            } 
            return true;
        } else if (left && right) {
            result = root;
            return true;
        }
        return left || right;
    }
}
```



------



## Lowest Common Ancestor of a Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

**Solution**

**二叉树**

这个题是**lca of a binary tree**的简化版，但用那个solution也能坐

这个多了一个binary search tree的条件 所以只要找到第一个夹在p， q中间的数就是lca

```java
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val > p.val && root.val > q.val){
            return lowestCommonAncestor(root.left, p, q);
        }else if(root.val < p.val && root.val < q.val){
            return lowestCommonAncestor(root.right, p, q);
        }else{
            return root;
        }
    }
}
```



------



## Lowest Common Ancestor of a Binary Tree III

Given two nodes of a binary tree `p` and `q`, return *their lowest common ancestor (LCA)*.

Each node will have a reference to its parent node. The definition for `Node` is below:

```
class Node {
    public int val;
    public Node left;
    public Node right;
    public Node parent;
}
```

According to the **[definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor)**: "The lowest common ancestor of two nodes p and q in a tree T is the lowest node that has both p and q as descendants (where we allow **a node to be a descendant of itself**)."

 

**Example 1:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
```

**Example 2:**

![img](https://assets.leetcode.com/uploads/2018/12/14/binarytree.png)

```
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5 since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [1,2], p = 1, q = 2
Output: 1
```



**Solution**

**Set** 从两个点往上走，最先遇到的点就是答案了 

```java
class Solution {
    
    public Node lowestCommonAncestor(Node p, Node q) {
        Set<Node> set = new HashSet<>();
        while(p != null) {
            set.add(p);
            p = p.parent;
        }
        while(q != null) {
            if(set.contains(q)) {
                return q;
            }
            q = q.parent;
        }
        throw new IllegalArgumentException("dont have a valid result");
    }
}
```



1. https://leetcode.com/problems/lo ... r-of-a-binary-tree/

Lint-474. Lowest Common Ancestor II
https://www.lintcode.com/problem ... stor-ii/description

Lint-578. Lowest Common Ancestor III
https://www.lintcode.com/problem ... cestor-iii/solution

# 其他

199. Binary Tree Right Side View
https://leetcode.com/problems/binary-tree-right-side-view/

513. Find Bottom Left Tree Value
https://leetcode.com/problems/find-bottom-left-tree-value/

331. Verify Preorder Serialization of a Binary Tree
https://leetcode.com/problems/ve ... n-of-a-binary-tree/

449. Serialize and Deserialize BST
https://leetcode.com/problems/serialize-and-deserialize-bst/

114. Flatten Binary Tree to Linked List
https://leetcode.com/problems/flatten-binary-tree-to-linked-list/



## Serialize and Deserialize Binary Tree

Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

**Clarification:** The input/output format is the same as [how LeetCode serializes a binary tree](https://leetcode.com/faq/#binary-tree). You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

**Example 1:**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
Input: root = [1,2,3,null,null,4,5]
Output: [1,2,3,null,null,4,5]
```

**Example 2:**

```
Input: root = []
Output: []
```

**Example 3:**

```
Input: root = [1]
Output: [1]
```

**Example 4:**

```
Input: root = [1,2]
Output: [1,2]
```

 **Solution**

- Time complexity : in both serialization and deserialization functions, we visit each node exactly once, thus the time complexity is O(N), where N*N is the number of nodes, *i.e.* the size of tree.
- Space complexity : in both serialization and deserialization functions, we keep the entire tree, either at the beginning or at the end, therefore, the space complexity is O(N)

```java
public class Codec {
    public String rserialize(TreeNode root, String str) {
    // Recursive serialization.
    if (root == null) {
      str += "null,";
    } else {
      str += str.valueOf(root.val) + ",";
      str = rserialize(root.left, str);
      str = rserialize(root.right, str);
    }
    return str;
  }

  // Encodes a tree to a single string.
  public String serialize(TreeNode root) {
    return rserialize(root, "");
  }
    
     public TreeNode rdeserialize(List<String> l) {
    // Recursive deserialization.
    if (l.get(0).equals("null")) {
      l.remove(0);
      return null;
    }

    TreeNode root = new TreeNode(Integer.valueOf(l.get(0)));
    l.remove(0);
    root.left = rdeserialize(l);
    root.right = rdeserialize(l);

    return root;
  }

  // Decodes your encoded data to tree.
  public TreeNode deserialize(String data) {
    String[] data_array = data.split(",");
    List<String> data_list = new LinkedList<String>(Arrays.asList(data_array));
    return rdeserialize(data_list);
  }
}
```

